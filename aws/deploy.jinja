{
    {#
     # This file is a Jinja template, and not a regular cloudformation template, because Amazon
     # makes it difficult to deploy a variable number of EC2 resources.  For full discussion of
     # why, see this: https://stackoverflow.com/a/41539208/2920686
     # This file is approach 2, template preprocessor with conditions.
     #
     # ASSUMPTIONS & DESIGN:
     # - Can only be deployed to regions with >=3 availability zones, for redundancy.
     # - Creates a separate EBS volume for /var/lib/neo4j, with adjustable size/encryption.
     # - Requires AMI IDs as built by our packer template included in this repo.
     # - Creates a new VPC to house neo4j, with 3 subnets corresponding to the AZs in use.
     #}
    {% if max_core_nodes is not defined %}
      {% set max_core_nodes = 7 %}
    {% endif %}
    {% if min_core_nodes is not defined %}
      {% set min_core_nodes = 3 %}
    {% endif %}

    {% if max_replica_nodes is not defined %}
        {% set max_replica_nodes = 5 %}
    {% endif %}
    {% if min_replica_nodes is not defined %}
        {% set min_replica_nodes = 0 %}
    {% endif %}

    {% if default_machine is not defined %}
      {% set default_machine = "r4.large" %}
    {% endif %}

    {% set INTERNAL_DNS_TLD = "neo4j" %}

    "Description": "Neo4j on AWS - creates a variable number of EC2 Ubuntu machines, a VPC, elastic IP addresses, and deploys the Neo4j Graph Database cluster on it.  **WARNING** This template creates an Amazon EC2 instance. You will be billed for the AWS resources used if you create a stack from this template.",
    "AWSTemplateFormatVersion": "2010-09-09",
    "Mappings": {        
        "AWSRegionArch2AMI": {% include 'template-parts/region2AMIMappings-enterprise.jinja' %}
    },
    "Parameters": {
        "InstanceType": {
            "Description": "EC2 instance type",
            "Type": "String",
            "Default": "{{default_machine}}",
            "AllowedValues": {% include 'template-parts/allowable-machine-types.jinja' %},
            "ConstraintDescription": "Must be a valid EC2 instance type."
        },
        "ClusterNodes": {
            "Description": "Number of core cluster node VMs",
            "Type": "Number",
            "Default": {{ min_core_nodes }},
            "MinValue": {{ min_core_nodes }},
            "MaxValue": {{ max_core_nodes }}
        },
        "ReadReplicas": {
            "Description": "Number of read replicas in the cluster",
            "Type": "Number",
            "Default": {{ min_replica_nodes }},
            "MinValue": {{ min_replica_nodes }},
            "MaxValue": {{ max_replica_nodes }}
        },
        "SSHKeyName": {
            "Description": "Name of an existing EC2 KeyPair to enable SSH access to the instances",
            "Type": "AWS::EC2::KeyPair::KeyName",
            "AllowedPattern": ".+"
        },
        "NetworkWhitelist": {
            "Description": " The IP address range that can be used to connect to Neo4j",
            "Type": "String",
            "MinLength": "9",
            "MaxLength": "18",
            "Default": "0.0.0.0/0",
            "AllowedPattern": "(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})/(\\d{1,2})",
            "ConstraintDescription": "must be a valid IP CIDR range of the form x.x.x.x/x.  For example, 0.0.0.0/0 for open internet access."
        },
        "Password": {
            "NoEcho": true,
            "Description": "initial neo4j password (uppercase, lowercase, and numbers only)",
            "Type": "String",
            "MinLength": 8,
            "MaxLength": 40,
            "AllowedPattern": "^[a-zA-Z0-9\\.-]+$"
        },
        "VolumeType": {
            "Description": "What kind of storage to attach",
            "Type": "String",
            "Default": "gp2",
            "AllowedValues": [
                "io1", "gp2", "st1"
            ]
        },
        "EncryptDataVolume": {
            "Description": "Should EBS storage be encrypted?  Default is yes.",
            "Type": "String",
            "Default": "true",
            "AllowedValues": [
                "true", "false"
            ]
        },
        "VolumeSizeGB": {
            "Description": "How much EBS storage is allocated to each cluster node, in GiB",
            "Type": "Number",
            "Default": "100",
            "MinValue": "10",
            "MaxValue": "1000",
            "ConstraintDescription": "Must be a valid EBS disk size in GiB."
        }
    },

    "Metadata": {
        "AWS::CloudFormation::Interface": {
            "ParameterGroups" : [
                {
                    "Label" : { "default" : "Cluster Configuration" },
                    "Parameters" : [ "ClusterNodes", "ReadReplicas" ]
                },
                {
                    "Label" : { "default": "Amazon EC2 Configuration" },
                    "Parameters" : [ "InstanceType", "VolumeType", "VolumeSizeGB", "EncryptDataVolume" ]
                },
                {
                    "Label": { "default": "Access Control" },
                    "Parameters": [ "SSHKeyName", "NetworkWhitelist", "Password" ]
                }
            ]
        }
    },

    "Conditions": {
        {# Bear in mind minimum cluster size is 3, so nodes 0, 1, 2 are always deployed.
         # CC deploys with < 3 nodes are not supported.
         # Also, node counting starts at 0, so when user chooses 4 nodes, they should
         # get 0, 1, 2, 3
         #}
        "CreateNode0": {"Fn::Equals" : [true, true]},
        "CreateNode1": {"Fn::Equals" : [true, true]},
        "CreateNode2": {"Fn::Equals" : [true, true]}{% if max_core_nodes > 3 %},{% endif %}        
        {% for i in range(3, max_core_nodes) %}
        "CreateNode{{i}}": {
            "Fn::Or": [                
                {% if i == (max_core_nodes - 1) %}
                    {# Last loop case will only have one statement, ORs must have min 2 #}
                    { "Fn::Equals": [0, 1] },
                {% endif %}

                {% for c in range(i, max_core_nodes, 1) %}
                { "Fn::Equals": [{ "Ref": "ClusterNodes" }, {{c + 1}} ]}{% if not loop.last %},{% endif %}
                {% endfor %}                
            ]
        },
        {% endfor %}

        {% for i in range(0, max_replica_nodes) %}
        "CreateReplica{{i}}": {
            "Fn::Or": [
                {% if i == (max_replica_nodes - 1) %}
                    {# Last loop case will only have one statement, ORs must have min 2 #}
                    { "Fn::Equals": [0, 1] },
                {% endif %}

                {% for c in range(i, max_replica_nodes, 1) %}
                { "Fn::Equals": [{ "Ref": "ReadReplicas" }, {{c + 1}} ]}{% if not loop.last %},{% endif %}
                {% endfor %}
            ]
        }{% if not loop.last %},{% endif %}
        {% endfor %}
    },
    "Resources": {
        "VPC" : {
            "Type" : "AWS::EC2::VPC",
            "Properties" : {
                "EnableDnsSupport" : "true",
                "EnableDnsHostnames" : "true",
                "InstanceTenancy": "default",
                "CidrBlock" : "10.0.0.0/16",
                "Tags" : [ 
                    {
                        "Key": "Name", 
                        "Value": {{ "Neo4jVPC" | appendStack }}
                    },
                    {"Key" : "Application", "Value" : { "Ref" : "AWS::StackId"} } 
                ]
            }
        },

        "DNSZone": {
            "Type": "AWS::Route53::HostedZone",
            "DependsOn" : "VPC",
            "Properties": {
                "HostedZoneConfig": {
                    "Comment": "Zone to define private DNS for neo4j nodes"
                },
                "Name": "{{ INTERNAL_DNS_TLD }}",
                "VPCs": [{
                    "VPCId": { "Ref": "VPC" },
                    "VPCRegion": { "Ref": "AWS::Region" }
                }],
                "HostedZoneTags" : [{
                    "Key": "Name",
                    "Value": {{ "Neo4jPrivateZone" | appendStack }}
                }]
            }            
        },

        {# Create three sets of subnets; this is needed because you need one
         # per AZ, with one route table association and network ACL association
         # for each.  Nodes get distributed across the subnets simple round robin,
         # meaning that node n goes into subnet n % 3 + 1.
         #}
        {% for i in range(0, 3) %}
        "Subnet{{i}}" : {
            "Type" : "AWS::EC2::Subnet",
            "Properties" : {
                "AvailabilityZone": {{ roundRobinAZ(i) }},
                "VpcId" : { "Ref" : "VPC" },
                "CidrBlock" : "10.0.{{i}}.0/24",
                "Tags" : [ 
                    {"Key": "Name", "Value": {{ ("Neo4jSubnet%d" % i) | appendStack }} },
                    {"Key" : "Application", "Value" : { "Ref" : "AWS::StackId"} } 
                ],
                "MapPublicIpOnLaunch": "true"
            }
        },

        "SubnetRouteTableAssociation{{i}}" : {
            "Type" : "AWS::EC2::SubnetRouteTableAssociation",
            "Properties" : {
                "SubnetId" : { "Ref" : "Subnet{{i}}" },
                "RouteTableId" : { "Ref" : "RouteTable" }
            }
        },

        "SubnetNetworkAclAssociation{{i}}" : {
            "Type" : "AWS::EC2::SubnetNetworkAclAssociation",
            "Properties" : {
                "SubnetId" : { "Ref" : "Subnet{{i}}" },
                "NetworkAclId" : { "Ref" : "NetworkAcl" }
            }
        },
        {% endfor %}

        "InternetGateway" : {
            "Type" : "AWS::EC2::InternetGateway",
            "Properties" : {                
                "Tags" : [ 
                    {"Key": "Name", "Value": {{ "Neo4jGateway" | appendStack }} },
                    {"Key" : "Application", "Value" : { "Ref" : "AWS::StackId"} } 
                ]
            }
        },

        "AttachGateway" : {
            "Type" : "AWS::EC2::VPCGatewayAttachment",
            "Properties" : {
                "VpcId" : { "Ref" : "VPC" },
                "InternetGatewayId" : { "Ref" : "InternetGateway" }
            }
        },

        "RouteTable" : {
            "Type" : "AWS::EC2::RouteTable",
            "Properties" : {
                "VpcId" : {"Ref" : "VPC"},
                "Tags" : [ 
                    {"Key": "Name", "Value": {{ "Neo4jRouteTable" | appendStack }} },
                    {"Key" : "Application", "Value" : { "Ref" : "AWS::StackId"} } 
                ]
            }
        },

        "Route" : {
            "Type" : "AWS::EC2::Route",
            "DependsOn" : "AttachGateway",
            "Properties" : {
                "RouteTableId" : { "Ref" : "RouteTable" },
                "DestinationCidrBlock" : { "Ref": "NetworkWhitelist" },
                "GatewayId" : { "Ref" : "InternetGateway" }
            }
        },

        "NetworkAcl" : {
            "Type" : "AWS::EC2::NetworkAcl",
            "Properties" : {
                "VpcId" : {"Ref" : "VPC"},
                "Tags" : [ {"Key" : "Application", "Value" : { "Ref" : "AWS::StackId"} } ]
            }
        },

        {# outbound HTTPS/HTTP must be permitted for awscli, package managers to work #}
        {% for reason, port in { "SSH": 22, "Bolt": 7689, "Neo4jHTTPS": 7473, "HTTPS": "443", "HTTP": "80" }.items() %}
            {% set outer_loop = loop %}
            {% for direction, egressBool in { "Ingress": False, "Egress": True }.items() %}
                "{{reason}}{{direction}}NetworkAclEntry": {
                    "Type" : "AWS::EC2::NetworkAclEntry",
                    "Properties" : {
                        "NetworkAclId" : {"Ref" : "NetworkAcl"},
                        "RuleNumber" : "{{100 + (outer_loop.index * loop.index) }}",
                        "Protocol" : "6", {# this means TCP #}
                        "RuleAction" : "allow",
                        "Egress" : "{{egressBool | string | lower }}",
                        "CidrBlock" : { "Ref": "NetworkWhitelist" },
                        "PortRange" : {"From" : "{{port}}", "To" : "{{port}}"}
                    }                
                },
            {% endfor %}
        {% endfor %}

        {# Internal causal cluster ports #}
        {% for reason, port in { "Int1": "5000", "Int2": "6000", "Int3": "7000" }.items() %}
            "{{reason}}NetworkAclEntry": {
                "Type" : "AWS::EC2::NetworkAclEntry",
                "Properties" : {
                    "NetworkAclId" : {"Ref" : "NetworkAcl"},
                    "RuleNumber" : "{{200 + loop.index}}",
                    "Protocol" : "6", {# this means TCP #}
                    "RuleAction" : "allow",
                    "Egress" : "true",
                    "CidrBlock" : "10.0.0.0/16",
                    "PortRange" : {"From" : "{{port}}", "To" : "{{port}}"}
                }                
            },        
        {% endfor %}

        "InboundResponsePortsNetworkAclEntry" : {
            "Type" : "AWS::EC2::NetworkAclEntry",
            "Properties" : {
                "NetworkAclId" : {"Ref" : "NetworkAcl"},
                "RuleNumber" : "300",
                "Protocol" : "6",
                "RuleAction" : "allow",
                "Egress" : "false",
                "CidrBlock" : { "Ref": "NetworkWhitelist" },
                "PortRange" : {"From" : "1024", "To" : "65535"}
            }
        },

        "OutBoundResponsePortsNetworkAclEntry" : {
            "Type" : "AWS::EC2::NetworkAclEntry",
            "Properties" : {
                "NetworkAclId" : {"Ref" : "NetworkAcl"},
                "RuleNumber" : "301",
                "Protocol" : "6",
                "RuleAction" : "allow",
                "Egress" : "true",
                "CidrBlock" : { "Ref": "NetworkWhitelist" },
                "PortRange" : {"From" : "1024", "To" : "65535"}
            }
        },

        "ReadOwnTags": {
            "Type": "AWS::IAM::Role",
            "Properties": {
                "RoleName": {{ "work-with-tags" | appendStack }},
                "AssumeRolePolicyDocument": { 
                    "Version": "2012-10-17",
                    "Statement": [
                        {
                            "Effect": "Allow",
                            "Principal": {
                                "Service": "ec2.amazonaws.com"
                            },
                            "Action": "sts:AssumeRole"
                        }
                    ]
                },
                "Policies": [
                    {
                        "PolicyName": "root",
                        {# Adapted/customized from arn:aws:iam::aws:policy/AmazonEC2ReadOnlyAccess #}
                        "PolicyDocument": {
                            "Version": "2012-10-17",
                            "Statement": [
                                {  
                                    "Effect": "Allow",
                                    "Action": "ec2:CreateTags",
                                    "Resource": "*"
                                },
                                {
                                    "Effect": "Allow",
                                    "Action": "ec2:Describe*",
                                    "Resource": "*"
                                },
                                {
                                    "Effect": "Allow",
                                    "Action": "elasticloadbalancing:Describe*",
                                    "Resource": "*"
                                },
                                {
                                    "Effect": "Allow",
                                    "Action": [
                                        "cloudwatch:ListMetrics",
                                        "cloudwatch:GetMetricStatistics",
                                        "cloudwatch:Describe*"
                                    ],
                                    "Resource": "*"
                                },
                                {
                                    "Effect": "Allow",
                                    "Action": "autoscaling:Describe*",
                                    "Resource": "*"
                                }
                            ]                            
                        }
                    }
                ]
            }
        },

        "instProfNeo4jEnterprise": {
            "Type": "AWS::IAM::InstanceProfile",
            "Properties": {
                "Roles": [{ "Ref": "ReadOwnTags"}],
                "InstanceProfileName": {{ "read-own-tags-ip" | appendStack }}
            }            
        },

        "sgNeo4jEnterprise": {
            "Type": "AWS::EC2::SecurityGroup",
            "Properties": {
                "VpcId" : { "Ref" : "VPC" },
                "GroupDescription": "Neo4j Ports",
                "SecurityGroupIngress": [
                    {# STRICTLY INTERNAL PORTS #}
                    {% for port in ["5000", "6000", "7000" ] %}
                    {
                        "IpProtocol": "tcp",
                        "FromPort": "{{port}}",
                        "ToPort": "{{port}}",
                        "CidrIp": "10.0.0.0/16"
                    },
                    {% endfor %}
                    {
                        "IpProtocol": "tcp",
                        "FromPort": "22",
                        "ToPort": "22",
                        "CidrIp": { "Ref": "NetworkWhitelist" }
                    },
                    {
                        "IpProtocol": "tcp",
                        "FromPort": "7687",
                        "ToPort": "7687",
                        "CidrIp": { "Ref": "NetworkWhitelist" }
                    },
                    {
                        "IpProtocol": "tcp",
                        "FromPort": "7473",
                        "ToPort": "7473",
                        "CidrIp": { "Ref": "NetworkWhitelist" }
                    }
                ]
            }
        },
        
        {# Create all of the resources given the cluster size #}
        {% for i in range(0, max_core_nodes) %}
        "Neo4jServer{{i}}DNS": {%
            with 
              condition="CreateNode%s" % i,
              groupName="node",
              resourceName="Neo4jServer%s" % i
        %} {% include 'template-parts/dnsentry.jinja' %}, {% endwith %}

        {# A Neo4jServerX is a core node #}
        "Neo4jServer{{i}}": {% 
                with
                    condition="CreateNode%s" % i,
                    dbms_mode="CORE" %} 
                {% include 'template-parts/neo4j-node.jinja' %}, 
            {% endwith %}
        {% endfor %}

        {% for i in range(0, max_replica_nodes) %}
        "Neo4jReplica{{i}}DNS": {%
                with 
                condition="CreateReplica%s" % i,
                groupName="replica",
                resourceName="Neo4jReplica%s" % i %} 
                {% include 'template-parts/dnsentry.jinja' %}, 
        {% endwith %}

        {# A Neo4jServerX is a core node #}
        "Neo4jReplica{{i}}": {% 
                with
                    condition="CreateReplica%s" % i,
                    dbms_mode="READ_REPLICA" %} 
                {% include 'template-parts/neo4j-node.jinja' %},
        {% endwith %}
        
        {% endfor %}

        {# This is signaled by vm-startup-snippet at the end #}
        "StackTokenWaitHandle" : {
            "Type" : "AWS::CloudFormation::WaitConditionHandle"
        },

        {#
         # We wait on a password reset signal from the underlying nodes, because it
         # is evidence that the causal cluster has formed, and the REST API is available.
         # In this way, user doesn't get cloudformation finished deploy signal until
         # the actual cluster is available for query; cluster formation time is baked in.
         #}
        "WaitOnPasswordReset": {
            "Type" : "AWS::CloudFormation::WaitCondition",
            "DependsOn": "Neo4jServer0",
            "Properties": {
                "Handle"  : { "Ref" : "StackTokenWaitHandle" },
                "Timeout" : "1800",
                "Count": "1"
            }
        }
    },
    "Outputs": {
        "Note": {
            "Value": {
                "Fn::Join": [
                    "\n",
                    [
                        "Your cluster is deployed, and currently forming.",
                        "Now is a good time to get a cup of coffee, the ",
                        "URL below should be available within a few minutes"
                    ]
                ]
            }
        },
        "IMPORTANT": {
            "Value": {
                "Fn::Join": [
                    "\n",
                    [
                    "PLEASE TAKE NOTE!  Your instance begins with an unsigned ",
                    "SSL certificate.  This means that in order to access your ",
                    "new system, you should configure your browser to trust this ",
                    "IP address on **both** port 7473 **and** port 7687, otherwise ",
                    "you may have issues connecting. ",
                    "For more information see https://community.neo4j.com/t/troubleshooting-connection-issues-to-neo4j/129"
                    ]
                ]
            }
        },
        "Neo4jWebadmin": {
            "Value": {
                "Fn::Join": [
                    "",
                    [
                        "https://",
                        {
                            "Fn::GetAtt": [
                                "Neo4jServer1",
                                "PublicIp"
                            ]
                        },
                        ":7473/"
                    ]
                ]
            },
            "Description": "This is the address of your Neo4j server web administration console."
        },
        "Username": {
            "Value": "neo4j"
        },
        "Password": {
            "Value": {
                "Ref": "Password"
            }
        },

        {# Each server signals back an instance ID into a dictionary, like:
         # { instanceId1: password, instanceId2: password }
         # They're all the same password, so just grab the first instance ID's
         # return value.
         # Right now this is not a desired output, but if used to generate a
         # strong random password, this is the way to do it.
        "GeneratedClusterPasswordVal": {
            "Value": {
                "Fn::GetAtt" : [ "WaitOnPasswordReset", "Data" ]
            }
        },
         #}
        "SSH": {
            "Value": {
                "Fn::Join": [
                    "",
                    [
                        "ssh -i ${HOME}/.ssh/",
                        { "Ref": "SSHKeyName" },
                        ".pem -l ubuntu@",
                        {
                            "Fn::GetAtt": [
                                "Neo4jServer1",
                                "PublicIp"
                            ]
                        }
                    ]
                ]
            },
            "Description": "This is how you gain remote access to the machine."
        },
        {% for i in range(0, 3) %}
        "Node{{i}}Ip": {
            "Value": { "Fn::GetAtt": [ "Neo4jServer{{i}}", "PublicIp" ] }
        }{% if not loop.last %},{% endif %}
        {% endfor %}
    }
}