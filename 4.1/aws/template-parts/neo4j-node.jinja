{#
 # This subtemplate creates an EC2 instance of neo4j.
 #
 # Not everything here is parameterized, it still expects arguments from the
 # main template, like SSHKeyName, and certain existing resources, like 
 # sgNeo4jEnterprise, instProfNeo4jEnterprise, and others.
 #
 # Requires variables:
 # condition: When to create this, by resource condition name.
 # dbms_mode: neo4j's database mode config, should be STANDALONE, CORE, READ_REPLICA
 # i: integer index, i.e. this is node i of 5 total.
 #}
{
    "Type": "AWS::EC2::Instance",
    "Condition" : "{{condition}}",
    "Properties": {
        "IamInstanceProfile": { "Ref": "instProfNeo4jEnterprise" },
        "AvailabilityZone": {{ roundRobinAZ(i) }},
        "DisableApiTermination": "FALSE",
        "ImageId": {
            "Fn::FindInMap": [ "AWSRegionArch2AMI", { "Ref": "AWS::Region" }, "64" ]
        },

        "NetworkInterfaces" : [{
            "GroupSet"                 : [{ "Ref" : "sgNeo4jEnterprise" }],
            "AssociatePublicIpAddress" : "true",
            "DeviceIndex"              : "0",
            "DeleteOnTermination"      : "true",
            "SubnetId"                 : { "Ref" : "Subnet{{ i % 3 }}" }
        }],
        
        "InstanceType": { "Ref": "InstanceType" },
        "KeyName": { "Ref": "SSHKeyName" },
        "Monitoring": "false",

        "Tags": [
            { 
                "Key": "Name", "Value": {{ ("neo4j-%s-vm-%s" % (dbms_mode, i)) | appendStack }}
            },                   
            { "Key": "Application", "Value": { "Ref" : "AWS::StackId"} },
            { "Key": "neo4j_mode", "Value": "cluster" },
            { "Key": "node_name", "Value": {% if dbms_mode == 'READ_REPLICA' %} "replica{{i}}.neo4j" {% else %} "node{{i}}.neo4j" {% endif %}},
            { "Key": "dbms_mode", "Value": "{{dbms_mode}}" },
            {#
                # Per cluster team, irrespective of cluster size we set initial size
                # to 3 (the mininum) and initial discovery set to the first 3.  This
                # should form cluster appropriately, even if there are 8, because
                # 4 - 8 know to contact 1 - 3.
                # Requires the assumption that clusters are never < 3 nodes.
                #}
            { 
                "Key": "causal_clustering_minimum_core_cluster_size_at_formation", 
                "Value": "3"
            },
            { 
                "Key": "causal_clustering_minimum_core_cluster_size_at_formation", 
                "Value": "3"
            },
            {
                "Key": "causal_clustering_initial_discovery_members",
                "Value": {
                    "Fn::Join": [
                        ",",
                        {#
                         # Node numbering starts at zero, and these hostnames correspond to those
                         # created by the DNS entries Neo4jServer(i)DNS in the main template.
                         #}
                        [
                            "node0.neo4j:5000",
                            "node1.neo4j:5000",
                            "node2.neo4j:5000"
                        ]
                    ]
                }
            },
            {
                "Key": "initial_password",
                "Value": { "Ref": "Password" }
            },
            { "Key": "InstanceID", "Value": { "Fn::Join": ["", [ { "Ref": "AWS::StackName" }, "{{i}}" ] ]} }
        ],
        "UserData": {
            "Fn::Base64": {"Fn::Join": [ "",
                {% include 'template-parts/vm-startup.snippet.jinja' %}
            ]}
        },
        "BlockDeviceMappings": [
            {
                "DeviceName": "/dev/sda1",
                "Ebs": {
                    "VolumeType": { "Ref": "VolumeType" },
                    "VolumeSize": "10",
                    "DeleteOnTermination": "true"
                }
            },
            {
                {# /dev/sdb will appear in the VM as /dev/xvdb, because reasons
                    # This volume will be formatted/mounted by vm-startup.snippet.jinja 
                    #}
                "DeviceName": "/dev/sdb",
                "Ebs": {
                    "VolumeType": { "Ref": "VolumeType" },
                    "VolumeSize": { "Ref": "VolumeSizeGB" },
                    "Encrypted": { "Ref": "EncryptDataVolume" }
                }
            }
        ]
    }
}